/**
 * @fileoverview Like `npm install` except will notice if changes have been
 *     made to local modules and update them.
 */
'use strict';
var assign = require('object-assign');
var co = require('co');
var denodeify = require('promise').denodeify;
var detectDependencyGraph = require('./util/detect_dependency_graph');
var exec = require('mz/child_process').exec;
var find = require('./util/find');
var manifest = require('' + process.cwd() + '/package.json');
var path = require('path');
var npm = require('npm');
var rimraf = denodeify(require('rimraf'));
var stat = require('mz/fs').stat;

module.exports = co.wrap(regeneratorRuntime.mark(function install(args) {
  var graph, latest, filestat;
  return regeneratorRuntime.wrap(function install$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        npmInstall = npmInstall.bind(null, args);
        graph = detectDependencyGraph(process.cwd());
        context$1$0.prev = 2;
        context$1$0.next = 5;
        return stat('' + process.cwd() + '/node_modules');

      case 5:
        filestat = context$1$0.sent;

        latest = filestat.ctime;
        context$1$0.next = 14;
        break;

      case 9:
        context$1$0.prev = 9;
        context$1$0.t0 = context$1$0['catch'](2);
        context$1$0.next = 13;
        return npmInstall();

      case 13:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 14:
        context$1$0.next = 16;
        return Object.keys(graph).map(co.wrap(regeneratorRuntime.mark(function callee$1$0(dependency) {
          return regeneratorRuntime.wrap(function callee$1$0$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                context$2$0.next = 2;
                return npmInstallIfDirty(latest, dependency, graph[dependency]);

              case 2:
              case 'end':
                return context$2$0.stop();
            }
          }, callee$1$0, this);
        })));

      case 16:
      case 'end':
        return context$1$0.stop();
    }
  }, install, this, [[2, 9]]);
}));

var npmInstall = co.wrap(regeneratorRuntime.mark(function callee$0$0(args) {
  var result;
  return regeneratorRuntime.wrap(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        context$1$0.next = 3;
        return denodeify(npm.load)();

      case 3:
        npm.config.set('production', args.production);
        context$1$0.next = 6;
        return denodeify(npm.install)();

      case 6:
        result = context$1$0.sent;
        context$1$0.next = 13;
        break;

      case 9:
        context$1$0.prev = 9;
        context$1$0.t0 = context$1$0['catch'](0);

        console.error(context$1$0.t0);
        return context$1$0.abrupt('return', Promise.reject(context$1$0.t0));

      case 13:

        process.stdout.write(result);

      case 14:
      case 'end':
        return context$1$0.stop();
    }
  }, callee$0$0, this, [[0, 9]]);
}));

// This thing is a hot mess.
var npmInstallIfDirty = co.wrap(regeneratorRuntime.mark(function callee$0$0(latest, dependency, dependencies) {
  var folders, dirty, key, folder, folderDirty, dependencyName, dependencyVersion;
  return regeneratorRuntime.wrap(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        folders = getAllKeys(dependencies);

        folders.push(dependency);

        dirty = false;
        context$1$0.t0 = regeneratorRuntime.keys(folders);

      case 4:
        if ((context$1$0.t1 = context$1$0.t0()).done) {
          context$1$0.next = 15;
          break;
        }

        key = context$1$0.t1.value;
        folder = folders[key];
        context$1$0.next = 9;
        return isFolderDirty(folder, latest);

      case 9:
        folderDirty = context$1$0.sent;

        if (!folderDirty) {
          context$1$0.next = 13;
          break;
        }

        dirty = true;
        return context$1$0.abrupt('break', 15);

      case 13:
        context$1$0.next = 4;
        break;

      case 15:
        if (dirty) {
          context$1$0.next = 17;
          break;
        }

        return context$1$0.abrupt('return');

      case 17:
        dependencyName = getDependencyName(dependency);
        context$1$0.next = 20;
        return rimraf('' + process.cwd() + '/node_modules/' + dependencyName);

      case 20:
        dependencyVersion = getDependencyVersion(dependencyName);
        context$1$0.next = 23;
        return npmInstall(dependencyVersion);

      case 23:
      case 'end':
        return context$1$0.stop();
    }
  }, callee$0$0, this);
}));

function getDependencyName(dependency) {
  var parts = dependency.split('/');
  dependency = parts[parts.length - 1];
  var dependencies = assign({}, manifest.dependencies || {}, manifest.devDependencies || {});

  for (var key in dependencies) {
    if (dependencies[key].endsWith(dependency)) {
      return key;
    }
  }
}

function getDependencyVersion(dependency) {
  var dependencies = assign({}, manifest.dependencies || {}, manifest.devDependencies || {});

  for (var key in dependencies) {
    if (key === dependency) {
      return dependencies[key];
    }
  }
}

/**
 * Checks whether a folder has is newer than another stats.
 */
var isFolderDirty = co.wrap(regeneratorRuntime.mark(function callee$0$0(folder, latest) {
  var files, key, file, filestat;
  return regeneratorRuntime.wrap(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return find(folder);

      case 2:
        files = context$1$0.sent;
        context$1$0.t0 = regeneratorRuntime.keys(files);

      case 4:
        if ((context$1$0.t1 = context$1$0.t0()).done) {
          context$1$0.next = 14;
          break;
        }

        key = context$1$0.t1.value;
        file = path.resolve(folder, files[key]);
        context$1$0.next = 9;
        return stat(file);

      case 9:
        filestat = context$1$0.sent;

        if (!(filestat.ctime > latest)) {
          context$1$0.next = 12;
          break;
        }

        return context$1$0.abrupt('return', true);

      case 12:
        context$1$0.next = 4;
        break;

      case 14:
        return context$1$0.abrupt('return', false);

      case 15:
      case 'end':
        return context$1$0.stop();
    }
  }, callee$0$0, this);
}));

function getAllKeys(object) {
  var result = [];
  var queue = [object];
  while (queue.length > 0) {
    var next = queue.shift();
    if (!Object.keys(next).length) {
      continue;
    }

    Object.keys(next).forEach(function (key) {
      result.push(key);
      queue.push(next[key]);
    });
  }

  return result;
}

// if node_modules doesn't exist, we absolutely have to `npm install`.

// Check for each local dependency whether it's been updated.
// TODO(gaye): Can Array.prototype.some() be used with co?

// co <> array/some ?
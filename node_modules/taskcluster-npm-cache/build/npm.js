"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

/**
Initialize the workspace with a temp directory.
*/
module.exports = init;

var temp = _interopRequire(require("promised-temp"));

var del = _interopRequire(require("delete"));

var denodeify = _interopRequire(require("denodeify"));

var eventToPromise = _interopRequire(require("event-to-promise"));

var Debug = _interopRequire(require("debug"));

var run = _interopRequire(require("./run"));

var format = require("util").format;

var fs = _interopRequire(require("mz/fs"));

var fsPath = _interopRequire(require("path"));

var download = _interopRequire(require("download"));

var downloadStatus = _interopRequire(require("download-status"));

var debug = Debug("npm-cache:workspace");

var Workspace = (function () {
  function Workspace(dir) {
    _classCallCheck(this, Workspace);

    this.dir = dir;
  }

  _createClass(Workspace, {
    destroy: {

      /**
      Destroy all temporary assets created.
      */

      value: function destroy() {
        var _this = this;

        return regeneratorRuntime.async(function destroy$(context$2$0) {
          while (1) switch (context$2$0.prev = context$2$0.next) {
            case 0:
              context$2$0.next = 2;
              return denodeify(del)(_this.dir, { force: true });

            case 2:
            case "end":
              return context$2$0.stop();
          }
        }, null, this);
      }
    },
    extract: {

      /**
      Extract package from remote target into given directory.
      */

      value: function extract(url, target) {
        var path, req;
        return regeneratorRuntime.async(function extract$(context$2$0) {
          while (1) switch (context$2$0.prev = context$2$0.next) {
            case 0:
              debug("extract", { url: url, target: target });
              path = fsPath.join(target, "node_modules.tar.gz");
              req = download().get(url).dest(target).use(downloadStatus());
              context$2$0.next = 5;
              return denodeify(req.run).call(req);

            case 5:
              context$2$0.next = 7;
              return run("tar", ["zxf", path], { cwd: target });

            case 7:
            case "end":
              return context$2$0.stop();
          }
        }, null, this);
      }
    },
    install: {

      /**
      Update or install node modules associated with the package json URL
      provided.
      */

      value: function install(pkg) {
        var _this = this;

        var pkgPath;
        return regeneratorRuntime.async(function install$(context$2$0) {
          while (1) switch (context$2$0.prev = context$2$0.next) {
            case 0:
              pkgPath = fsPath.join(_this.dir, "package.json");
              context$2$0.next = 3;
              return fs.exists(pkgPath);

            case 3:
              if (!context$2$0.sent) {
                context$2$0.next = 5;
                break;
              }

              throw new Error("Cannot run install twice (package.json exists)");

            case 5:
              context$2$0.next = 7;
              return fs.writeFile(pkgPath, JSON.stringify(pkg));

            case 7:
              context$2$0.next = 9;
              return run("npm", ["install"], {
                cwd: _this.dir
              });

            case 9:
            case "end":
              return context$2$0.stop();
          }
        }, null, this);
      }
    },
    exportTar: {

      /**
      Create a new tar containing node_modules and return path.
      */

      value: function exportTar() {
        var _this = this;

        var modulesPath, exportPath;
        return regeneratorRuntime.async(function exportTar$(context$2$0) {
          while (1) switch (context$2$0.prev = context$2$0.next) {
            case 0:
              modulesPath = fsPath.join(_this.dir, "node_modules");
              context$2$0.next = 3;
              return fs.exists(modulesPath);

            case 3:
              if (context$2$0.sent) {
                context$2$0.next = 5;
                break;
              }

              throw new Error("No modules to export (node_modules missing)");

            case 5:
              exportPath = fsPath.join(_this.dir, "node_modules.tar.gz");
              context$2$0.next = 8;
              return run("tar", ["czf", exportPath, "node_modules"], {
                cwd: _this.dir
              });

            case 8:
              return context$2$0.abrupt("return", exportPath);

            case 9:
            case "end":
              return context$2$0.stop();
          }
        }, null, this);
      }
    }
  });

  return Workspace;
})();

function init() {
  var dir;
  return regeneratorRuntime.async(function init$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return temp.mkdir("npm-cache");

      case 2:
        dir = context$1$0.sent;

        debug("create: %s", dir);
        return context$1$0.abrupt("return", new Workspace(dir));

      case 5:
      case "end":
        return context$1$0.stop();
    }
  }, null, this);
}

// XXXAus: We should get rid of this in favor of a platform agnostic
//         module.

// XXX: We may want to sanitize parts of this such as scripts which
//      effectively lets you run untrusted code.

// XXXAus: We should get rid of this in favor of a platform agnostic
//         module.
//# sourceMappingURL=npm.js.map
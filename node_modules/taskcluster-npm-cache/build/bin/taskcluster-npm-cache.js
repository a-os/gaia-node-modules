#! /usr/bin/env node
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

// This module is the entrypoint so it needs to import the polyfill...

require("babel/polyfill");

var ArgumentParser = require("argparse").ArgumentParser;

var assert = _interopRequire(require("assert"));

var Debug = _interopRequire(require("debug"));

var npm = _interopRequire(require("../npm"));

var taskcluster = _interopRequire(require("taskcluster-client"));

var request = _interopRequire(require("superagent-promise"));

var fs = _interopRequire(require("mz/fs"));

var fsPath = _interopRequire(require("path"));

var eventToPromise = _interopRequire(require("event-to-promise"));

var hash = _interopRequire(require("../hash"));

var signature = _interopRequire(require("../signature"));

var debug = new Debug("npm-cache:put");
var parser = new ArgumentParser();
parser.addArgument(["--task-id"], {
  help: "The task to run caching logic for",
  required: true,
  dest: "taskId"
});

parser.addArgument(["--run-id"], {
  help: "Run id for the particular task",
  dest: "runId",
  defaultValue: 0
});

parser.addArgument(["--namespace"], {
  defaultValue: "npm_cache",
  help: "Index namespace to use"
});

parser.addArgument(["--proxy"], {
  action: "storeTrue",
  help: "Rely on the taskcluster proxy service provided by the docker-worker"
});

function upload(queue, taskId, runId, expires, modulePath) {
  var size, tar, artifact, artifactUrl, put;
  return regeneratorRuntime.async(function upload$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return fs.stat(modulePath);

      case 2:
        size = context$1$0.sent.size;
        tar = fs.createReadStream(modulePath);
        artifact = {
          storageType: "s3",
          expires: expires,
          contentType: "application/x-tar"
        };
        context$1$0.next = 7;
        return queue.createArtifact(taskId, runId, "public/node_modules.tar.gz", artifact);

      case 7:
        artifactUrl = context$1$0.sent;
        put = request.put(artifactUrl.putUrl);

        put.set("Content-Length", size);
        put.set("Content-Type", "application/x-tar");
        put.set("Content-Encoding", "gzip");
        tar.pipe(put);
        put.end();
        context$1$0.next = 16;
        return eventToPromise(put, "end");

      case 16:
      case "end":
        return context$1$0.stop();
    }
  }, null, this);
}

function main() {
  var args, queueOpts, indexOpts, queue, index, task, url, expires, pkgReqs, pkgContents, pkg, checkForRemoval, pkgHash, namespace, indexedTask, workspace, moduleTar, indexPayload;
  return regeneratorRuntime.async(function main$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        checkForRemoval = function checkForRemoval(obj, key) {
          var val = obj[key];
          if (val.startsWith("file:") || val.startsWith(".") || val.startsWith("/") || val.startsWith("~")) {
            delete obj[key];
          }
        };

        args = parser.parseArgs(process.argv.slice(2));
        queueOpts = {};
        indexOpts = {};

        if (args.proxy) {
          queueOpts.baseUrl = "taskcluster/queue/v1";
          indexOpts.baseUrl = "taskcluster/index/v1";
        }

        queue = new taskcluster.Queue(queueOpts);
        index = new taskcluster.Index(indexOpts);
        context$1$0.next = 9;
        return queue.getTask(args.taskId);

      case 9:
        task = context$1$0.sent;

        if (!task.extra || !task.extra.npmCache) {
          console.error("Task must contain task.extra");
          process.exit(1);
        }

        url = task.extra.npmCache.url;

        if (!url) {
          console.error("Task must contain a extra.npmCache.url");
          process.exit(1);
        }

        expires = new Date(task.extra.npmCache.expires);

        if (!task.extra.npmCache.expires || expires < new Date()) {
          console.error("Task must contain extra.npmCache.expires and be in the future.");
          process.exit(1);
        }

        context$1$0.next = 17;
        return request.get(url).end();

      case 17:
        pkgReqs = context$1$0.sent;
        pkgContents = pkgReqs.text.trim();
        pkg = JSON.parse(pkgContents);

        // First we check the dependencies
        if (pkg.dependencies) {
          Object.keys(pkg.dependencies).forEach(function (key) {
            checkForRemoval(pkg.dependencies, key);
          });
        }
        // Next we'll check the devDependencies
        if (pkg.devDependencies) {
          Object.keys(pkg.devDependencies).forEach(function (key) {
            checkForRemoval(pkg.devDependencies, key);
          });
        }

        pkgHash = hash(pkgContents);
        namespace = "" + args.namespace + "." + signature() + "." + pkgHash;

        debug("Package hash =", pkgHash);
        debug("Package namespace =", namespace);

        context$1$0.prev = 26;
        context$1$0.next = 29;
        return index.findTask(namespace);

      case 29:
        indexedTask = context$1$0.sent;

        debug("Cache hit. Skipping tarball creation.");
        process.exit(0);
        context$1$0.next = 38;
        break;

      case 34:
        context$1$0.prev = 34;
        context$1$0.t1 = context$1$0["catch"](26);

        if (!(!err.statusCode || err.statusCode !== 404)) {
          context$1$0.next = 38;
          break;
        }

        throw context$1$0.t1;

      case 38:
        context$1$0.next = 40;
        return npm();

      case 40:
        workspace = context$1$0.sent;
        context$1$0.next = 43;
        return workspace.install(pkg);

      case 43:
        context$1$0.next = 45;
        return workspace.exportTar();

      case 45:
        moduleTar = context$1$0.sent;
        context$1$0.next = 48;
        return upload(queue, args.taskId, args.runId, expires, moduleTar);

      case 48:
        indexPayload = {
          taskId: args.taskId,
          rank: 0, // XXX: How should we define ranking?
          expires: expires,
          data: {}
        };
        context$1$0.next = 51;
        return index.insertTask(namespace, indexPayload);

      case 51:
      case "end":
        return context$1$0.stop();
    }
  }, null, this, [[26, 34]]);
}

main()["catch"](function (e) {
  process.nextTick(function () {
    console.error("Something is wrong...");
    throw e;
  });
});

//
// XXXAus: HACK HACK HACK!!! To enable gaia to use local module paths in
//         it's package.json we will STRIP OUT all entries (after hashing!)
//         which are referring to local in tree modules. These will be
//         installed later. We will be removing this hack when we have
//         exhibition rolled out in gaia.
//
// Figure out hash of contents and namespace.
// Check to see if we already have this package json cached...

// Insert the platform specific index namespace...
//# sourceMappingURL=taskcluster-npm-cache.js.map
#! /usr/bin/env node
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

// This module is the entrypoint so it needs to import the polyfill...

require("babel/polyfill");

var ArgumentParser = require("argparse").ArgumentParser;

var taskcluster = _interopRequire(require("taskcluster-client"));

var fs = _interopRequire(require("fs"));

var fsPath = _interopRequire(require("path"));

var Debug = _interopRequire(require("debug"));

var eventToPromise = _interopRequire(require("event-to-promise"));

var hash = _interopRequire(require("../hash"));

var signature = _interopRequire(require("../signature"));

var npm = _interopRequire(require("../npm"));

var temp = _interopRequire(require("promised-temp"));

var run = _interopRequire(require("../run"));

var debug = new Debug("npm-cache:get");
var parser = new ArgumentParser();
parser.addArgument(["--namespace"], {
  defaultValue: "npm_cache",
  help: "\n    Index namespace to use\n  "
});

parser.addArgument(["--target"], {
  defaultValue: process.cwd(),
  help: "\n    Location where to create node_modules\n  "
});

parser.addArgument(["--no-install"], {
  defaultValue: false,
  dest: "noInstall",
  help: "\n    Skip running npm install after fetching and extracting.\n    If you think you need to use this, you're probably wrong.\n  "
});

parser.addArgument(["package"], {
  help: "path to package.json",
  type: function type(path) {
    path = fsPath.resolve(path);
    if (!fs.existsSync(path)) {
      throw new Error("\"" + path + "\" cannot be found");
    }
    return path;
  }
});

function expandCacheNodeModules(url, modules) {
  var dir;
  return regeneratorRuntime.async(function expandCacheNodeModules$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return temp.mkdir("npm-cache");

      case 2:
        dir = context$1$0.sent;

      case 3:
      case "end":
        return context$1$0.stop();
    }
  }, null, this);
}

function main() {
  var args, index, queue, pkgText, pkgHash, namespace, indexedTask, url, workspace;
  return regeneratorRuntime.async(function main$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        args = parser.parseArgs(process.argv.slice(2));
        index = new taskcluster.Index();
        queue = new taskcluster.Queue();
        pkgText = fs.readFileSync(args["package"], { encoding: "utf8" });
        pkgHash = hash(pkgText.trim());
        namespace = "" + args.namespace + "." + signature() + "." + pkgHash;

        debug("Package hash =", pkgHash);
        debug("Package namespace =", namespace);

        indexedTask = undefined;
        context$1$0.prev = 9;
        context$1$0.next = 12;
        return index.findTask(namespace);

      case 12:
        indexedTask = context$1$0.sent;
        context$1$0.next = 19;
        break;

      case 15:
        context$1$0.prev = 15;
        context$1$0.t0 = context$1$0["catch"](9);

        if (!(!err.statusCode || err.statusCode !== 404)) {
          context$1$0.next = 19;
          break;
        }

        throw context$1$0.t0;

      case 19:
        if (indexedTask) {
          context$1$0.next = 24;
          break;
        }

        debug("Cache miss! Falling back to npm install.");
        context$1$0.next = 23;
        return run("npm", ["install"]);

      case 23:
        return context$1$0.abrupt("return");

      case 24:
        context$1$0.next = 26;
        return queue.buildUrl(queue.getLatestArtifact, indexedTask.taskId, "public/node_modules.tar.gz");

      case 26:
        url = context$1$0.sent;
        context$1$0.next = 29;
        return npm(args.target);

      case 29:
        workspace = context$1$0.sent;
        context$1$0.next = 32;
        return workspace.extract(url, args.target);

      case 32:
        if (!args.noInstall) {
          context$1$0.next = 34;
          break;
        }

        return context$1$0.abrupt("return");

      case 34:
        context$1$0.next = 36;
        return run("npm", ["install"]);

      case 36:
      case "end":
        return context$1$0.stop();
    }
  }, null, this, [[9, 15]]);
}

main()["catch"](function (e) {
  process.nextTick(function () {
    console.error("Something is wrong...");
    throw e;
  });
});
// Check to see if we already have this package json cached...

// Optionally skip 'npm install' if requested.
//# sourceMappingURL=taskcluster-npm-cache-get.js.map